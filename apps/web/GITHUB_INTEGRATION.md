# GitHub Integration & Backend Logic

This document details the backend logic and workflow for the GitHub integration in NeuroSync.

## 1. Overview

The GitHub integration allows NeuroSync to:
1.  **Authenticate**: Users connect their GitHub account/organizations via OAuth App.
2.  **Index**: The backend automatically fetches and indexes repositories, PRs, Issues, and Commits.
3.  **Sync**: Webhooks keep the data up-to-date in real-time.

## 2. Authentication Flow

**Frontend**:
*   User clicks "Connect GitHub" in the dashboard.
*   Redirects to `https://github.com/apps/neurosync-ai/installations/new`.

**Backend (`/api/github/callback`)**:
1.  **Callback**: GitHub redirects to this route with a `code` and `installation_id`.
2.  **Exchange**: Logic exchanges `code` for an `access_token`.
3.  **Storage**: Logic stores the installation details in `github_installations` table.
    - `user_id`: Link to NeuroSync user.
    - `installation_id`: GitHub's ID.
    - `access_token`: Token for API requests.

## 3. Data Ingestion Logic (How it works)

Once connected, the backend needs to ingest data. This is typically handled by a background worker or a scheduled job (Cron), coupled with Webhooks for real-time updates.

### A. Initial Sync (Historical Data)

When a new installation is created, a background job is triggered:
1.  **Fetch Repositories**: `GET /installation/repositories` to list all accessible repos.
2.  **For Each Repository**:
    - **Fetch Pull Requests**: `GET /repos/{owner}/{repo}/pulls?state=all`.
    - **Fetch Issues**: `GET /repos/{owner}/{repo}/issues`.
    - **Fetch Commits**: `GET /repos/{owner}/{repo}/commits` (optional/limit to recent).
3.  **Process & Store**:
    - Convert GitHub objects into NeuroSync `Memory` objects or structured `Graph` nodes.
    - Generate embeddings for semantic search.
    - Store in vector database and relational DB.

### B. Real-time Sync (Webhooks)

The GitHub App is configured to send Webhooks to `/api/github/webhook`.

**Supported Events**:
*   `push`: New commits code.
*   `pull_request`: PR opened, closed, merged.
*   `issues`: Issue opened, labeled, closed.

**Webhook Logic**:
1.  **Verify Signature**: Ensure request is from GitHub.
2.  **Identify User**: Find which NeuroSync user owns the `installation_id`.
3.  **Process Event**:
    - If `push`: Analyze diffs, update code context.
    - If `issue`: Create/Update memory node for the issue.
4.  **Update Graph**: Link new events to existing nodes (e.g., link a PR to the Issue it closes).

## 4. Implementation Plan

To fully enable this:

### 1. Database Schema
Ensure the `github_installations` table exists as referenced in the callback route.
```sql
create table github_installations (
  id bigint generated by default as identity primary key,
  user_id uuid references auth.users not null,
  installation_id bigint not null unique,
  account_login text,
  account_type text,
  access_token text,
  refresh_token text,
  expires_at timestamptz,
  created_at timestamptz default now()
);
```

### 2. Setup GitHub App
*   **Homepage URL**: `https://your-domain.com`
*   **Callback URL**: `https://your-domain.com/api/github/callback`
*   **Webhook URL**: `https://your-domain.com/api/github/webhook`
*   **Permissions**:
    - Contents: Read-only (for code)
    - Issues: Read-only
    - Pull Requests: Read-only
    - Metadata: Read-only

### 3. Background Workers
Use a queue system (like BullMQ or Inngest) or simple Cron jobs to handle the "Initial Sync" to avoid timing out HTTP requests.
